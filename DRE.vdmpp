class DRE
instance variables
	private code: nat1 :=9999;
	private memory: map Voter to Candidate := {|->} ;
	private log: seq of RTAL :=[];
	private CurrentPBE: PBE;
	private StateMachine: VoteState := new VoteState();
	private CurrentChoice: Candidate := new Candidate(); 
	private CurrentVoter: Voter := new Voter();
operations
-- Constructor
	public DRE: PBE ==> DRE 
	DRE(pbe) == (
							dcl logEntry: RTAL;
							CurrentPBE := pbe;
							StateMachine.toStop();
						 	logEntry := new RTAL("Election Started");
							log := log ^ [logEntry];
							return self)
	pre 
		pbe.ballot <> {}
		and pbe.voters <> {}
		and pbe.code = code
	post 
		self.CurrentPBE.ballot = pbe.ballot
		and self.CurrentPBE.voters = pbe.voters;
		
--Register Votes to Memory
	public RegisterVote: Voter * Candidate ==> ()
	RegisterVote(v,c) == memory := memory munion {v|->c}
	pre c.name <> []
		and v.code>=1000
		and v.code<=9999
		and v.name <> []
	post memory = {v|->c} ++ memory~;

--Get Results

--Voting sequence state machine
	
	public StartVote: Voter ==> ()
	StartVote(v) == (
			dcl logEntry: RTAL;
			
			logEntry := new RTAL("Started voting: " ^ v.name);
			log := log ^ [logEntry];
			StateMachine.toInit();
			CurrentVoter := v;
			--Memory := Memory munion {v|->c};
	)
	pre StateMachine.currentState=<STOP>
			and v in set CurrentPBE.voters
			and v not in set dom memory
	post StateMachine.currentState=<INIT>
			 and v = CurrentVoter;

	public Vote: Candidate ==> ()
	Vote(c) == (
			dcl logEntry: RTAL;
			
			logEntry := new RTAL(CurrentVoter.name ^ "voted in " ^ c.name);
			log := log ^ [logEntry];
			StateMachine.toConfirm();
			CurrentChoice := c
	)
	pre StateMachine.currentState=<INIT>
			and CurrentVoter in set CurrentPBE.voters
			and c in set CurrentPBE.ballot
	post StateMachine.currentState=<CONFIRM>
			 and c = CurrentChoice
			 and CurrentVoter in set CurrentPBE.voters
			 and CurrentChoice in set CurrentPBE.ballot;
	
	public ConfirmVote: bool ==>()
	ConfirmVote(confirm) == (
			if(confirm)
			then(
					dcl logEntry: RTAL;
					StateMachine.toDone();

					logEntry := new RTAL("Confirmed:" ^ CurrentVoter.name ^ "has voted in " ^ CurrentChoice.name);
					log := log ^ [logEntry];
					memory:= memory munion {CurrentVoter|->CurrentChoice};
					CurrentChoice := new Candidate();
					CurrentVoter := new Voter();
					StateMachine.toStop()
					)
			else(
					dcl logEntry: RTAL;
					logEntry := new RTAL("Canceled:" ^ CurrentVoter.name ^ "has canceled the vote in " ^ CurrentChoice.name);
					log := log ^ [logEntry];
					CurrentChoice := new Candidate();
					StateMachine.toInit();
					)
	)
	pre StateMachine.currentState=<CONFIRM> 
			and CurrentVoter.name <> []
			and CurrentChoice.name <> []
	post (StateMachine.currentState=<STOP>
			 and card dom memory = (card dom memory~ )+1)
			 or (
			 StateMachine.currentState=<INIT>)
			 and card dom memory = card dom memory~;
end DRE